<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Random Student Picker</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <header>
    <a href="https://github.com/snow-jallen/RandomStudentPicker" target="_blank" rel="noopener noreferrer" style="flex:1;font-weight:600;display:flex;align-items:center;gap:10px;text-decoration:none;">
      <img src="logo.svg" alt="Random Student Picker" style="width:32px;height:32px;" />
      <span style="background:var(--gradient-primary);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;">Random Student Picker</span>
    </a>
    <div style="display:flex; gap:12px; align-items:center;">
      <select id="themeSelect" style="padding:8px 12px; color:#ffffff !important; -webkit-text-fill-color:#ffffff !important;">
        <option value="dark" style="color:#ffffff; background:#111;">Dark</option>
        <option value="ocean" style="color:#ffffff; background:#111;">Ocean</option>
        <option value="sunset" style="color:#ffffff; background:#111;">Sunset</option>
        <option value="forest" style="color:#ffffff; background:#111;">Forest</option>
      </select>
      <nav><a href="settings.html">Settings</a></nav>
    </div>
  </header>
  <main>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <h1 style="margin:0;">Picker</h1>
      <select id="groupSelect" style="padding:8px 12px;">
        <option value="">Loading...</option>
      </select>
    </div>
    <div class="picker-container">
      <div class="dice-area" id="diceArea" style="display:none;">
        <div class="dice-wrapper" id="diceWrapper"></div>
      </div>
      <div class="result" id="result"></div>
      <button id="pickBtn">Pick Random Student</button>
      <div class="status-line" id="statusLine"></div>
    </div>

    <div class="groups-section">
      <h2>Random Groups</h2>
      <div class="groups-controls">
        <label for="groupSize">Group size:</label>
        <input type="number" id="groupSize" min="2" max="10" value="2" />
        <button id="createGroupsBtn" class="secondary">Create Random Groups</button>
      </div>
      <div id="groupsDisplay"></div>
    </div>
  </main>
  <footer>Data stored locally. <a class="inline-link" href="settings.html">Manage students</a>.</footer>
  <script src="storage.js"></script>
  <script>
    const pickBtn = document.getElementById('pickBtn');
    const resultEl = document.getElementById('result');
  const diceArea = document.getElementById('diceArea');
  const diceWrapper = document.getElementById('diceWrapper');
    const statusLine = document.getElementById('statusLine');
    const groupSelect = document.getElementById('groupSelect');
    const themeSelect = document.getElementById('themeSelect');

    function populateGroupDropdown() {
      const allGroups = RSP.getAllGroups();
      const currentGroup = RSP.getCurrentGroup();

      groupSelect.innerHTML = '';

      allGroups.forEach(group => {
        const option = document.createElement('option');
        option.value = group.id;
        option.textContent = group.title;
        if (currentGroup && group.id === currentGroup.id) {
          option.selected = true;
        }
        groupSelect.appendChild(option);
      });
    }

    function handleGroupChange() {
      const selectedGroupId = groupSelect.value;
      if (selectedGroupId && RSP.setCurrentGroup(selectedGroupId)) {
        updateStatus();
      }
    }

    function updateStatus() {
      const currentGroup = RSP.getCurrentGroup();
      const students = RSP.getStudents();

      if (!students.length) {
        statusLine.textContent = 'No students yet. Go to Settings to add some.';
      } else {
        const activeStudents = students.filter(s => !s.excluded);
        const excludedCount = students.length - activeStudents.length;

        if (activeStudents.length === 0) {
          statusLine.textContent = `All ${students.length} students are excluded. Go to Settings to include some.`;
        } else {
          const counts = activeStudents.map(s => s.picks.length);
          const min = Math.min(...counts);
          const max = Math.max(...counts);
          const cycles = currentGroup ? currentGroup.cycles || 1 : 1;

          // Show cycle progress
          const completedStudents = activeStudents.filter(s => s.picks.length >= cycles).length;
          const cycleProgress = cycles > 1 ? ` | Cycle progress: ${completedStudents}/${activeStudents.length} complete` : '';

          // Show excluded count if any
          const excludedInfo = excludedCount > 0 ? ` (${excludedCount} excluded)` : '';

          statusLine.textContent = `Students: ${activeStudents.length}${excludedInfo} | Pick count range: ${min}-${max}/${cycles}${cycleProgress}`;
        }
      }
    }

    // Dice logic (3D cube)
    const FACE_PATTERNS = {
      1: [5],
      2: [1,9],
      3: [1,5,9],
      4: [1,3,7,9],
      5: [1,3,5,7,9],
      6: [1,3,4,6,7,9]
    };

    function createFace(className, value) {
      const face = document.createElement('div');
      face.className = 'dice-face ' + className;
      const pattern = FACE_PATTERNS[value];
      for (let i=1;i<=9;i++) {
        if (pattern.includes(i)) {
          const pip = document.createElement('div');
          pip.className = 'pip';
          if (value === 1) pip.classList.add('big');
          face.appendChild(pip);
        } else {
          face.appendChild(document.createElement('div'));
        }
      }
      return face;
    }

    function buildDiceCube(initialValue) {
      const dice = document.createElement('div');
      dice.className = 'dice';
      const core = document.createElement('div');
      core.className = 'core';
      const sizeHalf = 39; // half of 78px
      // Faces mapping: front=1, right=2, top=3, bottom=4, left=5, back=6
      const front = createFace('front',1); front.style.transform = `translateZ(${sizeHalf}px)`;
      const back = createFace('back',6); back.style.transform = `rotateY(180deg) translateZ(${sizeHalf}px)`;
      const right = createFace('right',2); right.style.transform = `rotateY(90deg) translateZ(${sizeHalf}px)`;
      const left = createFace('left',5); left.style.transform = `rotateY(-90deg) translateZ(${sizeHalf}px)`;
      const top = createFace('top',3); top.style.transform = `rotateX(90deg) translateZ(${sizeHalf}px)`;
      const bottom = createFace('bottom',4); bottom.style.transform = `rotateX(-90deg) translateZ(${sizeHalf}px)`;
      core.append(front, back, right, left, top, bottom);
      dice.appendChild(core);
      orientDiceToValue(dice, initialValue || 1); // initial
      return dice;
    }

    function orientDiceToValue(dice, value) {
      const core = dice.querySelector('.core');
      // Orientation mapping
      let rx=0, ry=0;
      switch(value) {
        case 1: rx=0; ry=0; break; // front
        case 2: rx=0; ry=-90; break; // right
        case 3: rx=-90; ry=0; break; // top
        case 4: rx=90; ry=0; break; // bottom
        case 5: rx=0; ry=90; break; // left
        case 6: rx=0; ry=180; break; // back
      }
      core.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`;
      dice.dataset.value = value;
    }

    function orientDiceToValueSmooth(dice, value, current) {
      const core = dice.querySelector('.core');
      let baseRx=0, baseRy=0;
      switch(value) {
        case 1: baseRx=0; baseRy=0; break;
        case 2: baseRx=0; baseRy=-90; break;
        case 3: baseRx=-90; baseRy=0; break;
        case 4: baseRx=90; baseRy=0; break;
        case 5: baseRx=0; baseRy=90; break;
        case 6: baseRx=0; baseRy=180; break;
      }
      // Choose multiples of 360 to minimize travel from current angles
      function nearest(targetBase, currentAngle) {
        let k = Math.round((currentAngle - targetBase)/360);
        return targetBase + 360*k;
      }
      const targetRx = nearest(baseRx, current.angleX);
      const targetRy = nearest(baseRy, current.angleY);
      // Normalize Z toward nearest 360 multiple (remove spin) smoothly
      const targetRz = 360 * Math.round(current.angleZ / 360);
      core.style.transition = 'transform .55s cubic-bezier(.19,1.1,.22,1)';
      requestAnimationFrame(()=> {
        core.style.transform = `rotateX(${targetRx}deg) rotateY(${targetRy}deg) rotateZ(${targetRz}deg)`;
      });
      dice.dataset.value = value;
    }

    function randomInt(min, max) { return Math.floor(Math.random()*(max-min+1))+min; }

  let animationFrame = null;
  let diceObjects = [];

    function startDiceAnimation() {
      const count = randomInt(2,5);
      diceWrapper.innerHTML='';
      diceArea.style.display='block';
      const areaW = diceArea.clientWidth;
      const areaH = diceArea.clientHeight;
      diceObjects = [];
      for (let i=0;i<count;i++) {
        const el = buildDiceCube(randomInt(1,6));
        diceWrapper.appendChild(el);
        const size = 78;
        diceObjects.push({
          el,
          core: el.querySelector('.core'),
          x: Math.random()*(areaW - size),
          y: Math.random()*(areaH - size),
          vx: (Math.random()*600 - 300),
          vy: (Math.random()*600 - 300),
          angleX: Math.random()*360,
          angleY: Math.random()*360,
          angleZ: Math.random()*360,
          vax: (Math.random()*1080 - 540),
          vay: (Math.random()*1080 - 540),
          vaz: (Math.random()*1080 - 540)
        });
      }
      const start = performance.now();
      const duration = 1000; // ms
      function step(now) {
        const dt = (now - (step.last || now))/1000; step.last = now;
        const elapsed = now - start;
        const damping = 0.989; // less damping -> faster movement
        const gravity = 380; // stronger gravity
        const size = 78;
        diceObjects.forEach(o => {
          o.vy += gravity * dt; // gravity
          o.vx *= damping; o.vy *= damping;
          o.x += o.vx * dt; o.y += o.vy * dt;
          if (o.x < 0) { o.x = 0; o.vx = Math.abs(o.vx)*0.75; }
          if (o.x > areaW - size) { o.x = areaW - size; o.vx = -Math.abs(o.vx)*0.75; }
          if (o.y < 0) { o.y = 0; o.vy = Math.abs(o.vy)*0.75; }
          if (o.y > areaH - size) { o.y = areaH - size; o.vy = -Math.abs(o.vy)*0.55; }
          o.angleX += o.vax * dt; o.angleY += o.vay * dt; o.angleZ += o.vaz * dt;
          o.vax *= damping; o.vay *= damping; o.vaz *= damping;
          o.el.style.transform = `translate3d(${o.x}px, ${o.y}px, 0)`;
          o.core.style.transform = `rotateX(${o.angleX}deg) rotateY(${o.angleY}deg) rotateZ(${o.angleZ}deg)`;
        });
        if (elapsed < duration) {
          animationFrame = requestAnimationFrame(step);
        } else {
          diceObjects.forEach(o => {
            o.el.classList.add('landed');
            const finalVal = randomInt(1,6);
            orientDiceToValueSmooth(o.el, finalVal, { angleX:o.angleX, angleY:o.angleY, angleZ:o.angleZ });
          });
        }
      }
      animationFrame = requestAnimationFrame(step);
    }

    function stopDiceAnimation() {
      if (animationFrame) cancelAnimationFrame(animationFrame);
    }

    // Sound management
    const CELEBRATION_SOUNDS = [
      'sounds/cheer1.mp3',
      'sounds/cheer2.mp3',
      'sounds/applause1.mp3',
      'sounds/applause2.mp3',
      'sounds/celebration1.mp3',
      'sounds/celebration2.mp3'
    ];

    let diceRollingAudio = null;

    function playRandomCelebrationSound() {
      const randomSound = CELEBRATION_SOUNDS[Math.floor(Math.random() * CELEBRATION_SOUNDS.length)];
      const audio = new Audio(randomSound);
      audio.volume = 0.7; // Set volume to 70%
      audio.play().catch(error => {
        // Silently handle audio play errors (e.g., user hasn't interacted with page yet)
        console.log('Audio play failed:', error);
      });
    }

    function playDiceRollingSound() {
      // Stop any existing dice rolling sound
      if (diceRollingAudio) {
        diceRollingAudio.pause();
        diceRollingAudio.currentTime = 0;
      }

      diceRollingAudio = new Audio('sounds/dice-rolling.mp3');
      diceRollingAudio.volume = 0.5; // Set volume to 50% for background sound
      diceRollingAudio.play().catch(error => {
        console.log('Dice rolling audio play failed:', error);
      });
    }

    function stopDiceRollingSound() {
      if (diceRollingAudio) {
        diceRollingAudio.pause();
        diceRollingAudio.currentTime = 0;
        diceRollingAudio = null;
      }
    }

    pickBtn.addEventListener('click', () => {
      const students = RSP.getStudents();
      if (!students.length) { alert('Add students first in Settings.'); return; }
      const activeStudents = students.filter(s => !s.excluded);
      if (!activeStudents.length) { alert('All students are excluded. Go to Settings to include some.'); return; }
      pickBtn.disabled = true;
      resultEl.textContent = '';
      startDiceAnimation();
      playDiceRollingSound();
      setTimeout(() => {
        const picked = RSP.pickRandom();
        stopDiceAnimation();
        stopDiceRollingSound();

        if (picked) {
          // Clear any existing animation classes
          resultEl.className = '';
          resultEl.textContent = picked.name;

          // Play celebration sound
          playRandomCelebrationSound();

          // Trigger the reveal animation
          requestAnimationFrame(() => {
            resultEl.classList.add('student-reveal');

            // Add random sparkles around the name
            const sparkleCount = Math.floor(Math.random() * 6) + 4; // 4-9 sparkles
            const resultRect = resultEl.getBoundingClientRect();
            const centerX = resultRect.width / 2;
            const centerY = resultRect.height / 2;

            for (let i = 0; i < sparkleCount; i++) {
              const sparkle = document.createElement('div');
              sparkle.className = 'animation-sparkle';
              sparkle.textContent = '✨';

              // Random angle and distance from center
              const angle = Math.random() * Math.PI * 2;
              const distance = 150 + Math.random() * 100; // 150-250px from center
              const x = centerX + Math.cos(angle) * distance;
              const y = centerY + Math.sin(angle) * distance;

              sparkle.style.setProperty('--sparkle-delay', `${Math.random() * 0.5}s`);
              sparkle.style.setProperty('--sparkle-duration', `${1.5 + Math.random() * 1}s`);
              sparkle.style.setProperty('--sparkle-x', `${x}px`);
              sparkle.style.setProperty('--sparkle-y', `${y}px`);
              resultEl.appendChild(sparkle);
            }
          });

          // After animation completes, apply final state and hide dice
          setTimeout(() => {
            resultEl.classList.remove('student-reveal');
            resultEl.classList.add('student-final');
            // Remove sparkles
            resultEl.querySelectorAll('.animation-sparkle').forEach(s => s.remove());
            // Hide dice area
            diceArea.style.display = 'none';
          }, 1200);

        } else {
          resultEl.textContent = 'No student selected.';
        }

        pickBtn.disabled = false;
        updateStatus();
      }, 1000);
    });

    // Theme management
    const themes = {
      dark: {
        '--bg-primary': '#0a0a0a',
        '--bg-secondary': '#111111',
        '--bg-tertiary': '#1a1a1a',
        '--bg-elevated': '#222222',
        '--accent-primary': '#6366f1',
        '--accent-secondary': '#8b5cf6',
        '--gradient-primary': 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)',
      },
      ocean: {
        '--bg-primary': '#0a1628',
        '--bg-secondary': '#0f1f3a',
        '--bg-tertiary': '#1a2f4a',
        '--bg-elevated': '#243b5c',
        '--accent-primary': '#06b6d4',
        '--accent-secondary': '#0891b2',
        '--gradient-primary': 'linear-gradient(135deg, #06b6d4 0%, #3b82f6 100%)',
      },
      sunset: {
        '--bg-primary': '#1a0a0a',
        '--bg-secondary': '#2a1111',
        '--bg-tertiary': '#3a1a1a',
        '--bg-elevated': '#4a2222',
        '--accent-primary': '#f97316',
        '--accent-secondary': '#ea580c',
        '--gradient-primary': 'linear-gradient(135deg, #f97316 0%, #dc2626 100%)',
      },
      forest: {
        '--bg-primary': '#0a1a0a',
        '--bg-secondary': '#112a11',
        '--bg-tertiary': '#1a3a1a',
        '--bg-elevated': '#224a22',
        '--accent-primary': '#10b981',
        '--accent-secondary': '#059669',
        '--gradient-primary': 'linear-gradient(135deg, #10b981 0%, #14b8a6 100%)',
      }
    };

    function applyTheme(themeName) {
      const theme = themes[themeName];
      if (!theme) return;

      const root = document.documentElement;
      Object.keys(theme).forEach(property => {
        root.style.setProperty(property, theme[property]);
      });

      localStorage.setItem('selectedTheme', themeName);
    }

    function updateThemeOptions() {
      const currentTheme = themeSelect.value;
      Array.from(themeSelect.options).forEach(option => {
        const themeName = option.value.charAt(0).toUpperCase() + option.value.slice(1);
        if (option.value === currentTheme) {
          option.textContent = `✓ ${themeName}`;
        } else {
          option.textContent = themeName;
        }
      });
    }

    function loadTheme() {
      const savedTheme = localStorage.getItem('selectedTheme') || 'dark';
      themeSelect.value = savedTheme;
      applyTheme(savedTheme);
      updateThemeOptions();
    }

    themeSelect.addEventListener('change', () => {
      applyTheme(themeSelect.value);
      updateThemeOptions();
    });

    // Add event listener for group selection
    groupSelect.addEventListener('change', handleGroupChange);

    // Initialize the page
    loadTheme();
    populateGroupDropdown();
    updateStatus();

    // Random Groups functionality
    const createGroupsBtn = document.getElementById('createGroupsBtn');
    const groupSizeInput = document.getElementById('groupSize');
    const groupsDisplay = document.getElementById('groupsDisplay');

    function createRandomGroups() {
      const students = RSP.getStudents();
      const activeStudents = students.filter(s => !s.excluded);

      if (!activeStudents.length) {
        alert('No active students to group. Go to Settings to add or include students.');
        return;
      }

      const groupSize = parseInt(groupSizeInput.value);
      if (groupSize < 2 || groupSize > activeStudents.length) {
        alert(`Group size must be between 2 and ${activeStudents.length}.`);
        return;
      }

      // Shuffle students randomly
      const shuffled = [...activeStudents].sort(() => Math.random() - 0.5);

      // Calculate groups
      const totalStudents = shuffled.length;
      const remainder = totalStudents % groupSize;
      let numGroups = Math.floor(totalStudents / groupSize);

      const groups = [];
      let currentIndex = 0;

      // Handle remainder based on group size
      if (remainder === 0) {
        // Perfect division
        for (let i = 0; i < numGroups; i++) {
          groups.push(shuffled.slice(currentIndex, currentIndex + groupSize));
          currentIndex += groupSize;
        }
      } else if (groupSize === 2) {
        // For pairs, make one group of 3
        for (let i = 0; i < numGroups; i++) {
          groups.push(shuffled.slice(currentIndex, currentIndex + groupSize));
          currentIndex += groupSize;
        }
        if (remainder > 0) {
          // Add remaining students to last group (making it 3)
          groups[groups.length - 1].push(...shuffled.slice(currentIndex));
        }
      } else if (groupSize === 3) {
        // For groups of 3, handle remainder intelligently
        if (remainder === 1) {
          // Make one group of 4 instead
          for (let i = 0; i < numGroups - 1; i++) {
            groups.push(shuffled.slice(currentIndex, currentIndex + groupSize));
            currentIndex += groupSize;
          }
          // Last group gets 4 students
          groups.push(shuffled.slice(currentIndex));
        } else if (remainder === 2) {
          // Make one group of 2
          for (let i = 0; i < numGroups; i++) {
            groups.push(shuffled.slice(currentIndex, currentIndex + groupSize));
            currentIndex += groupSize;
          }
          groups.push(shuffled.slice(currentIndex));
        }
      } else {
        // For group sizes 4+, never exceed the group size
        // Make full groups, then a smaller group for remainder
        for (let i = 0; i < numGroups; i++) {
          groups.push(shuffled.slice(currentIndex, currentIndex + groupSize));
          currentIndex += groupSize;
        }
        if (remainder > 0) {
          // Create a separate smaller group for remainder
          groups.push(shuffled.slice(currentIndex));
        }
      }

      displayGroups(groups);
    }

    function displayGroups(groups) {
      if (!groups.length) {
        groupsDisplay.innerHTML = '';
        return;
      }

      const colors = [
        'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
        'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
        'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
        'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
        'linear-gradient(135deg, #30cfd0 0%, #330867 100%)',
        'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
        'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
        'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
        'linear-gradient(135deg, #ff6e7f 0%, #bfe9ff 100%)'
      ];

      let html = '<div class="groups-grid">';
      groups.forEach((group, index) => {
        const gradient = colors[index % colors.length];
        html += `
          <div class="group-card" style="background: ${gradient};">
            <div class="group-header">Group ${index + 1}</div>
            <div class="group-members">
              ${group.map(student => `<div class="member-name">${student.name}</div>`).join('')}
            </div>
            <div class="group-count">${group.length} member${group.length !== 1 ? 's' : ''}</div>
          </div>
        `;
      });
      html += '</div>';

      groupsDisplay.innerHTML = html;
    }

    createGroupsBtn.addEventListener('click', createRandomGroups);
  </script>
</body>
</html>
